

# This file was *autogenerated* from the file attack.sage
from sage.all_cmdline import *   # import sage library

_sage_const_7 = Integer(7); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_8 = Integer(8)
import networkx as nx
import matplotlib.pyplot as plt
from sage.all import *

n = _sage_const_7 
m = _sage_const_2 
p = _sage_const_2 **n * _sage_const_3 **m - _sage_const_1 
F = GF(p**_sage_const_2 , 'i', modulus=x**_sage_const_2 +_sage_const_1 , names=('i',)); (i,) = F._first_ngens(1)

PR = F['t']; (t,) = PR._first_ngens(1)
def H_p(t):
    m = (p-_sage_const_1 )//_sage_const_2 
    return sum([binomial(m, i)**_sage_const_2  * t**i for i in range(m+_sage_const_1 )])

lambdas = [r[_sage_const_0 ] for r in H_p(t).roots() if r[_sage_const_0 ] not in [_sage_const_0 ,_sage_const_1 ]]

def subgroup_gen(E, l):
     Ptilde, Qtilde = E.gens()
     P, Q = ((p+_sage_const_1 )//l) * Ptilde, ((p+_sage_const_1 )//l) * Qtilde
     return P, Q
     

def walk_graph_1(E, S, P_s, Q_s, l, d):
	E_new, P_new, Q_new, S_new = E, P_s, Q_s, S
	
	for i in range(d, _sage_const_0 , -_sage_const_1 ):
		S_step = l**(i-_sage_const_1 ) * S_new
		phi = EllipticCurveIsogeny(E_new, [E_new(_sage_const_0 ), S_step])
		E_new = phi.codomain()
		P_new, Q_new, S_new = phi(P_new), phi(Q_new), phi(S_new)
	
	return E_new, P_new, Q_new


def walk_graph_2(E, S, l, d):
	E_new, S_new = E, S
	
	for i in range(d, _sage_const_0 , -_sage_const_1 ):
		S_step = l**(i-_sage_const_1 ) * S_new
		phi = EllipticCurveIsogeny(E_new, [E_new(_sage_const_0 ), S_step])
		E_new = phi.codomain()
		S_new = phi(S_new)
	
	return E_new

E = EllipticCurve(F, [_sage_const_0 , F(-lambdas[_sage_const_0 ]-_sage_const_1 ), _sage_const_0 , lambdas[_sage_const_0 ], _sage_const_0 ])
PA, QA = subgroup_gen(E, _sage_const_2 **n)
PB, QB = subgroup_gen(E, _sage_const_3 **m)

print()
print("Predeclared values:")
print("Initial elliptic curve:", E)
print("Alice's basis:", PA, QA)
print("Bob's basis:", PB, QB)
print()

import random
kA = random.randint(_sage_const_0 , _sage_const_2 **n - _sage_const_1 )

SA = PA + kA*QA
EA, phiA_PB, phiA_QB = walk_graph_1(E, SA, PB, QB, _sage_const_2 , n)

print()
print("Public key computation:")
print("Alice's secret kA:", kA)
print("Alice's public key:", EA, phiA_PB, phiA_QB)
print()

def oracle(E, R, S, E_j):
	return E_j == walk_graph_2(E, R + kA*S, _sage_const_2 , n).j_invariant()

K = _sage_const_0 
for i in range(n-_sage_const_3 ):
	kB = random.randint(_sage_const_0 , _sage_const_3 **m - _sage_const_1 )
	EB, R, S = walk_graph_1(E, PB + kB*QB, PA, QA, _sage_const_3 , m)
	EAB_j = walk_graph_2(EA, phiA_PB + kB*phiA_QB, _sage_const_3 , m).j_invariant()
	theta = int((_sage_const_1 /mod(_sage_const_1  + _sage_const_2 **(n-i-_sage_const_1 ), _sage_const_2 **n)).sqrt())
	tmp = oracle(EB,  theta*(R - _sage_const_2 **(n-i-_sage_const_1 ) * K * S), theta*(_sage_const_1  + _sage_const_2 **(n-i-_sage_const_1 )) * S, EAB_j)
	K = K + _sage_const_2 **i * (tmp == _sage_const_0 )
	print("computed bits:", bin(K))

for i in range(_sage_const_8 ):
	K_g = K + i * _sage_const_2 **(n-_sage_const_3 )
	if(EA == walk_graph_2(E, PA+K_g*QA, _sage_const_2 , n)):
		print("Alice's secret: ", K_g)


